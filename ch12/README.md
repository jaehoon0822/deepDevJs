# 함수 

<br />

## 함수 정의
<br />

### 함수 선언문

> ***" 함수 선언문은 표현식이 아니라 문이다. "***   
***" 표현식과 문은 서로 다르다. 표현식은 값으로써 평가 될 수 있는문 이며 문은 프로그램을 구성하는 기본단위이자 최소 실행단위이다. "***   
   
이는 함수에서도 적용된다. 함수 선언문은 말 그대로 함수라고 선언하는 것이다. 하지만 표현식이 아니기에 값으로써 평가되지 않는다.   
자바스크립트 엔진은 함수 선언문의 함수명을 암묵적으로 생성하고, 할당한다. 이 말은 함수명 역시 변수처럼 작용한다는 것이다.   
hoisting 은 워낙에 유명한 자바스크립트의 특성이다. 다음을 보자.
>

```javascript

let arr = [ 1, 2, 3, 4 ];
let multiplyArr = map( arr, ( val ) => val * 2 ); // 함수작성 전에 함수를 호출한다. 작동할까?

console.log( muliplyArr ); // [ 2, 4, 6, 7 ]

function map( arr, func ) {
	const len = arr.length;
	let newArr = [];
	for ( let i = 0; i < len; i++ ) {
		newArr[i] = func( arr[i], i, arr );	
	}
	return newArr;
}

```

> 함수호출이 잘 작동한다. 이 말은 함수역시 변수처럼 호이스팅 된다는 것이다.   
다른 점이라면, 암묵적으로 식별자를 만들어 함수객채의 주소를 할당한다는 것이다.   
변수는 undefined 로 초기화 되는 것과는 대조된다.   
다음을 보자.
>

```javascript

let arr = [ 1, 2, 3, 4 ];
let multiplyArr = map( arr, ( val ) => val * 2 ); // Uncaught ReferenceError: map is not defined

console.log( muliplyArr ); // Uncaught ReferenceError: a is not defined

const map = function ( arr, func ) {
	const len = arr.length;
	let newArr = [];
	for ( let i = 0; i < len; i++ ) {
		newArr[i] = func( arr[i], i, arr );	
	}
	return newArr;
}

```

> 함수를 변수에 할당했다. 변수에 할당가능하다는 것은 값으로써 평가된다는 것이다.   
이 말은 표현식이다. 자바스크립트 엔진은 함수가 피연산자일때, 함수를 표현식으로 평가한다.
   
이러한 함수 표현식에 사용된 함수를 ***" 함수 리터럴 "*** 이라 한다.   
함수 리터럴은 보통 함수이름을 생략해서 사용( 익명함수 )하지만, 이름을 포함( 기명함수 )할수도 있다.   

책에서는 ***" 함수를 호출할 때는 함수 이름이 아니라 함수 객체를 가리키는 식별자를 사용해야 한다. "*** 라고 한다.   

이말은 위의 함수 표현식을 호출할때는 함수를 가리키는 map 을 사용해 호출한다.   
만약, 함수 이름이 존재하는 함수 표현식이라면 함수이름은 함수 내부에서만 사용가능하다.
>

<br />

### 함수 생성 시점과 함수 호이스팅

<br />

> ***" 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다. "***   
   
결국 변수처럼 호이스팅 된다는 말이다.
>

<br />


### Function 생성자 함수

<br />

> ***" Function 생성자 함수로 생성한 함수는 클로저를 생성하지 않는 등, 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 동작한다. "*** 
>

<br />

### 화살표 함수(ES6)

> 화살표 함수는 일반 함수와 다른점이 존재한다.   
1. 익명함수로 작성한다.   
2. this 바인딩 방식이 다르다.   
3. prototype 객체가 없다.
4. arguments 객체를 생성하지 않는다.
>

<br />

## 참조에 의한 전달과 외부 상태의 변경

<br />

> ***" 객체의 변경을 추적 하는 것은 어려운일 이다. 객체의 변경을 추적하려면 옵저버 패턴등을 통해 객체를 참조를 공유하는 모든 읻르에게 변경사실을 통지하고 이에 대처하는 추가 대응이 필요하다. "***
>

> ***" 이러한 문제의 해결 방법 중 하느는 객체를 불변 객체로 만들어 사용하는 것이다. "***
>

<br />

## 다양한 함수의 형태

<br />

### 중첩함수

<br />

> ***" ES6 부터 함수 정의는 문이 위치할 수 있는 문맥이라면 어디든지 가능하다. "***
>

<br />

> ***" 단, 호이스팅으로 인해 혼란이 발생할 수 있으므로 코드 블록에서 함수 선언문을 통해 함수를 정의하는 것은 바람직하지 않다. "***

<br />

### 콜백 함수

<br />

> ***" 함수의 변하지 않는 공통로직은 미리 정의해 두고, 경우에 따라 변경되는 로직은 추상화해서 함수 외부에서 함수 내부로 전달하는 것이다. "***
>

<br />

> ***" 함수의 매개변수를 통해 다른 함수의 내부로 전달되는 함수를 콜백함수라고 하며, 매개 변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수를 고차함수 라고 한다. "***
>

<br />


### 순수 함수와 비순수 함수

> ***" 함수형 프로그래밍에서는 어떤 외부 상태에 의존하지도 않고 벼ㄴ경하지도 않는, 즉 부수효과가 없는 함수를 순수함수( pure function ) 라 하고, 외부 상태에 의존하거나 외부 상태를 변경하는, 즉 부수효과가 있는 함수를 비순수 함수( impure function )라고 한다. "***
>

> ***" 함수형 프로그래밍은 순수 함수와 보조 함수의 조합을 통해 외부 상태를 변경하는 부수 효과를 최소화해서 불변성을 지향하는 프로그래밍 패러다임이다. ... 변수 사용을 억제하거나 생명주기를 최소화해서 상태 변경을 피해 오류를 최소화 하는 것을 목표로 한다. "***
>

<br />

> 여기서 함수형 자바스크립트에 대해 개념을 설명해 주고 있지만, 다른 책을 보고 더 자세히 살펴볼 필요가 있다.
>









>
